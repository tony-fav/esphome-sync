substitutions:
  friendly_name: d1mini devgroup

esphome:
  name: d1mini-devgroup
  platform: ESP8266
  board: d1_mini
  includes:
    - d1mini-devgroup.h     # #define statements for this device
<<<<<<< HEAD
    - ehdgr/support_device_groups_compat.h  # compatibility layer so support_device_groups_ehdgr.h need not be modified too much
    - ehdgr/support_device_groups_ehdgr.h   # support_device_groups.ino modified as minimally as possible
  on_boot:
    priority: -100
    then:
      - script.execute: start_and_loop_dev_group
=======
    - device_groups_reqs.h
    - device_groups.h
  # on_boot:
  #   priority: -100
  #   then:
  #     - script.execute: start_and_loop_dev_group
>>>>>>> 93b04d1982ec9c308a3303fe5a09b49b67adb742
      
    
logger:
  logs:
    script: INFO

api:

ota:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_pass
  manual_ip: # use a static IP so that sync'ing controller always knows what IP to use for control.
    static_ip: !secret d1minidevgroup_ip
    gateway: !secret wifi_gateway
    subnet: !secret wifi_subnet

  ap:
    ssid: "${friendly_name} Hotspot"
    password: !secret ap_password
    
  output_power: 17

captive_portal:

web_server:

output:
  - platform: esp8266_pwm
    pin: GPIO5
    id: pwm_pin

script:
  - id: start_and_loop_dev_group
    mode: restart
    then:
      - lambda: |-
          // do the device group things
          static int state = 0;
          if (state == 0) {
            InitTasmotaCompatibility();
            state = 1;
          }
          DeviceGroupsStart();
          DeviceGroupsLoop();
      - lambda: |-
          // debug messages
          static unsigned long last_output_time = millis();
          if (millis() < last_output_time + 10000) return;
          last_output_time = millis();
          ESP_LOGI("DGR", "%d, %d, %d, %d, %d, %d, %d, %d, %d - %d - %d, %d, %d, %d, %d", 
          ehdgr_power_1,  ehdgr_power_2,  ehdgr_power_3,  
          ehdgr_power_4,  ehdgr_power_5,  ehdgr_power_6,  
          ehdgr_power_7,  ehdgr_power_8,  ehdgr_power_9,
          ehdgr_brightness,
          ehdgr_channel_1, ehdgr_channel_2, ehdgr_channel_3, ehdgr_channel_4, ehdgr_channel_5);
      - lambda: |-
          // update light 1 state
          static bool state = id(my_light).current_values.get_state();
          static int brightness = id(my_light).current_values.get_brightness()*255;
          
          if (!id(use_dgr).state) return;
          
          bool set_state_on  = false;
          bool set_state_off = false;
          bool set_brightness = false;
          
          if (state != ehdgr_power_9) {
            if (ehdgr_power_9) {
              set_state_on = true;
            } else {
              set_state_off = true;
            }
          }
          if (ehdgr_power_9 && (brightness != ehdgr_brightness)) {
            set_brightness = true;
          }
          
          if (set_state_on || set_brightness) {
            brightness = ehdgr_brightness;
            state = true;
            
            auto call = id(my_light).turn_on();
            call.set_brightness((float)brightness/255.0f);
            call.set_transition_length(0);
            call.perform();
          }
          
          if (set_state_off) {
            state = false;
            
            auto call = id(my_light).turn_off();
            call.set_transition_length(0);
            call.perform();
          }
      - delay: 50ms
      - script.execute: start_and_loop_dev_group
  
  - id: stop_dev_group
    mode: single
    then:
      - script.stop: start_and_loop_dev_group
      - lambda: |-
          DeviceGroupsStop();

switch:
  - platform: template
    name: "Enable DGR"
    id: enable_dgr
    lambda: |-
      if (id(start_and_loop_dev_group).is_running()) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - script.execute: start_and_loop_dev_group
    turn_off_action:
      - script.execute: stop_dev_group
    
  - platform: template
    id: use_dgr
    name: "Use DGR"
    optimistic: true

light:
  - platform: monochromatic
    name: $friendly_name
    id: my_light
    output: pwm_pin